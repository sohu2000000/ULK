/*
 *	linux/mm/filemap.c
 *
 * Copyright (C) 1994-1999  Linus Torvalds
 */

/*
 * This file handles the generic file mmap semantics used by
 * most "normal" filesystems (but you don't /have/ to use this:
 * the NFS filesystem used to do this differently, for example)
 */
#include <linux/config.h>
#include <linux/module.h>
#include <linux/slab.h>
#include <linux/compiler.h>
#include <linux/fs.h>
#include <linux/aio.h>
#include <linux/kernel_stat.h>
#include <linux/mm.h>
#include <linux/swap.h>
#include <linux/mman.h>
#include <linux/pagemap.h>
#include <linux/file.h>
#include <linux/uio.h>
#include <linux/hash.h>
#include <linux/writeback.h>
#include <linux/pagevec.h>
#include <linux/blkdev.h>
#include <linux/security.h>
#include <linux/syscalls.h>
/*
 * This is needed for the following functions:
 *  - try_to_release_page
 *  - block_invalidatepage
 *  - generic_osync_inode
 *
 * FIXME: remove all knowledge of the buffer layer from the core VM
 */
#include <linux/buffer_head.h> /* for generic_osync_inode */

#include <asm/uaccess.h>
#include <asm/mman.h>

/*
 * Shared mappings implemented 30.11.1994. It's not fully working yet,
 * though.
 *
 * Shared mappings now work. 15.8.1995  Bruno.
 *
 * finished 'unifying' the page and buffer cache and SMP-threaded the
 * page-cache, 21.05.1999, Ingo Molnar <mingo@redhat.com>
 *
 * SMP-threaded pagemap-LRU 1999, Andrea Arcangeli <andrea@suse.de>
 */

/*
 * Lock ordering:
 *
 *  ->i_mmap_lock		(vmtruncate)
 *    ->private_lock		(__free_pte->__set_page_dirty_buffers)
 *      ->swap_list_lock
 *        ->swap_device_lock	(exclusive_swap_page, others)
 *          ->mapping->tree_lock
 *
 *  ->i_sem
 *    ->i_mmap_lock		(truncate->unmap_mapping_range)
 *
 *  ->mmap_sem
 *    ->i_mmap_lock
 *      ->page_table_lock	(various places, mainly in mmap.c)
 *        ->mapping->tree_lock	(arch-dependent flush_dcache_mmap_lock)
 *
 *  ->mmap_sem
 *    ->lock_page		(access_process_vm)
 *
 *  ->mmap_sem
 *    ->i_sem			(msync)
 *
 *  ->i_sem
 *    ->i_alloc_sem             (various)
 *
 *  ->inode_lock
 *    ->sb_lock			(fs/fs-writeback.c)
 *    ->mapping->tree_lock	(__sync_single_inode)
 *
 *  ->i_mmap_lock
 *    ->anon_vma.lock		(vma_adjust)
 *
 *  ->anon_vma.lock
 *    ->page_table_lock		(anon_vma_prepare and various)
 *
 *  ->page_table_lock
 *    ->swap_device_lock	(try_to_unmap_one)
 *    ->private_lock		(try_to_unmap_one)
 *    ->tree_lock		(try_to_unmap_one)
 *    ->zone.lru_lock		(follow_page->mark_page_accessed)
 *    ->private_lock		(page_remove_rmap->set_page_dirty)
 *    ->tree_lock		(page_remove_rmap->set_page_dirty)
 *    ->inode_lock		(page_remove_rmap->set_page_dirty)
 *    ->inode_lock		(zap_pte_range->set_page_dirty)
 *    ->private_lock		(zap_pte_range->__set_page_dirty_buffers)
 *
 *  ->task->proc_lock
 *    ->dcache_lock		(proc_pid_lookup)
 */

/*
 * Remove a page from the page cache and free it. Caller has to make
 * sure the page is locked and that nobody else uses it - or that usage
 * is safe.  The caller must hold a write_lock on the mapping's tree_lock.
 */
/**
 * 从页高速缓存中删除页描述符
 */
void __remove_from_page_cache(struct page *page)
{
	struct address_space *mapping = page->mapping;

	/**
	 * radix_tree_delete根据页索引从根节点开始遍历树，并执行删除操作
	 */
	radix_tree_delete(&mapping->page_tree, page->index); /*★*/
	/**
	 * 设置mapping字段
	 */
	page->mapping = NULL; /*★*/
	/**
	 * 把所缓存页的nrpages值减1.
	 */
	mapping->nrpages--; 
	/**
	 * 递减缓存页计数。
	 */
	pagecache_acct(-1);
}

/**
 * 从页高速缓存中删除页描述符
 */
void remove_from_page_cache(struct page *page)
{
	struct address_space *mapping = page->mapping;

	if (unlikely(!PageLocked(page)))
		PAGE_BUG(page);
	/**
	 * 获取自旋并关中断。
	 */
	spin_lock_irq(&mapping->tree_lock);
	/**
	 * __remove_from_page_cache真正从树中删除节点。
	 */
	__remove_from_page_cache(page); /*★*/
	/**
	 * 释放锁并关中断。
	 */
	spin_unlock_irq(&mapping->tree_lock);
}

static int sync_page(void *word)
{
	struct address_space *mapping;
	struct page *page;

	page = container_of((page_flags_t *)word, struct page, flags);

	/*
	 * FIXME, fercrissake.  What is this barrier here for?
	 */
	smp_mb();
	mapping = page_mapping(page);
	if (mapping && mapping->a_ops && mapping->a_ops->sync_page)
		mapping->a_ops->sync_page(page);
	io_schedule();
	return 0;
}

/**
 * filemap_fdatawrite_range - start writeback against all of a mapping's
 * dirty pages that lie within the byte offsets <start, end>
 * @mapping: address space structure to write
 * @start: offset in bytes where the range starts
 * @end : offset in bytes where the range ends
 *
 * If sync_mode is WB_SYNC_ALL then this is a "data integrity" operation, as
 * opposed to a regular memory * cleansing writeback.  The difference between
 * these two operations is that if a dirty page/buffer is encountered, it must
 * be waited upon, and not just skipped over.
 */
/* 回写文件节点的数据到磁盘 */
static int __filemap_fdatawrite_range(struct address_space *mapping,
	loff_t start, loff_t end, int sync_mode)
{
	int ret;
	struct writeback_control wbc = {
		.sync_mode = sync_mode,
		.nr_to_write = mapping->nrpages * 2,
		.start = start,
		.end = end,
	}; /*★*/

	if (mapping->backing_dev_info->memory_backed)
		return 0;

	ret = do_writepages(mapping, &wbc); /*★*/
	return ret;
}

static inline int __filemap_fdatawrite(struct address_space *mapping,
	int sync_mode)
{
	return __filemap_fdatawrite_range(mapping, 0, 0, sync_mode);
}

int filemap_fdatawrite(struct address_space *mapping)
{
	return __filemap_fdatawrite(mapping, WB_SYNC_ALL);
}
EXPORT_SYMBOL(filemap_fdatawrite);

static int filemap_fdatawrite_range(struct address_space *mapping,
	loff_t start, loff_t end)
{
	return __filemap_fdatawrite_range(mapping, start, end, WB_SYNC_ALL);
}

/*
 * This is a mostly non-blocking flush.  Not suitable for data-integrity
 * purposes - I/O may not be started against all dirty pages.
 */
int filemap_flush(struct address_space *mapping)
{
	return __filemap_fdatawrite(mapping, WB_SYNC_NONE);
}
EXPORT_SYMBOL(filemap_flush);

/*
 * Wait for writeback to complete against pages indexed by start->end
 * inclusive
 */
static int wait_on_page_writeback_range(struct address_space *mapping,
				pgoff_t start, pgoff_t end)
{
	struct pagevec pvec;
	int nr_pages;
	int ret = 0;
	pgoff_t index;

	if (end < start)
		return 0;

	pagevec_init(&pvec, 0);
	index = start;
	while ((index <= end) &&
			(nr_pages = pagevec_lookup_tag(&pvec, mapping, &index, /*pvec ★*/
			PAGECACHE_TAG_WRITEBACK,
			min(end - index, (pgoff_t)PAGEVEC_SIZE-1) + 1)) != 0) {
		unsigned i;

		for (i = 0; i < nr_pages; i++) {
			struct page *page = pvec.pages[i];

			/* until radix tree lookup accepts end_index */
			if (page->index > end)
				continue;

			wait_on_page_writeback(page); /*★*/
			if (PageError(page))
				ret = -EIO;
		}
		pagevec_release(&pvec);
		cond_resched();
	}

	/* Check for outstanding write errors */
	if (test_and_clear_bit(AS_ENOSPC, &mapping->flags))
		ret = -ENOSPC;
	if (test_and_clear_bit(AS_EIO, &mapping->flags))
		ret = -EIO;

	return ret;
}

/*
 * Write and wait upon all the pages in the passed range.  This is a "data
 * integrity" operation.  It waits upon in-flight writeout before starting and
 * waiting upon new writeout.  If there was an IO error, return it.
 *
 * We need to re-take i_sem during the generic_osync_inode list walk because
 * it is otherwise livelockable.
 */
int sync_page_range(struct inode *inode, struct address_space *mapping,
			loff_t pos, size_t count)
{
	pgoff_t start = pos >> PAGE_CACHE_SHIFT;
	pgoff_t end = (pos + count - 1) >> PAGE_CACHE_SHIFT;
	int ret;

	if (mapping->backing_dev_info->memory_backed || !count)
		return 0;
	/**
	 * 调用address_space对象的writepages方法或者mpage_writepages函数来开始脏页的传输。
	 */
	ret = filemap_fdatawrite_range(mapping, pos, pos + count - 1); /*★*/
	if (ret == 0) {
		down(&inode->i_sem);
		/**
		 * 将索引节点和相关的缓冲区刷新到磁盘。
		 */
		ret = generic_osync_inode(inode, mapping, OSYNC_METADATA); /*★*/
		up(&inode->i_sem);
	}

	/**
	 * 挂起当前进程一直到全部所刷新页的PG_writeback标志清0.
	 */
	if (ret == 0)
		ret = wait_on_page_writeback_range(mapping, start, end); /*★*/
	return ret;
}
EXPORT_SYMBOL(sync_page_range);

/*
 * Note: Holding i_sem across sync_page_range_nolock is not a good idea
 * as it forces O_SYNC writers to different parts of the same file
 * to be serialised right until io completion.
 */
int sync_page_range_nolock(struct inode *inode, struct address_space *mapping,
			loff_t pos, size_t count)
{
	pgoff_t start = pos >> PAGE_CACHE_SHIFT;
	pgoff_t end = (pos + count - 1) >> PAGE_CACHE_SHIFT;
	int ret;

	if (mapping->backing_dev_info->memory_backed || !count)
		return 0;
	ret = filemap_fdatawrite_range(mapping, pos, pos + count - 1);
	if (ret == 0)
		ret = generic_osync_inode(inode, mapping, OSYNC_METADATA);
	if (ret == 0)
		ret = wait_on_page_writeback_range(mapping, start, end);
	return ret;
}
EXPORT_SYMBOL(sync_page_range_nolock);

/**
 * filemap_fdatawait - walk the list of under-writeback pages of the given
 *     address space and wait for all of them.
 *
 * @mapping: address space structure to wait for
 */
/* 等待文件回写完成 */
int filemap_fdatawait(struct address_space *mapping)
{
	loff_t i_size = i_size_read(mapping->host);

	if (i_size == 0)
		return 0;

	return wait_on_page_writeback_range(mapping, 0,
				(i_size - 1) >> PAGE_CACHE_SHIFT);
}
EXPORT_SYMBOL(filemap_fdatawait);

/* 回写文件 */
int filemap_write_and_wait(struct address_space *mapping)
{
	int retval = 0;

	if (mapping->nrpages) {/* 文件长度不为0 */
		/* 回写数据 */
		retval = filemap_fdatawrite(mapping); /*★*/
		if (retval == 0)
			/* 等待回写完成 */
			retval = filemap_fdatawait(mapping); /*★*/
	}
	return retval;
}

/*
 * This function is used to add newly allocated pagecache pages:
 * the page is new, so we can just run SetPageLocked() against it.
 * The other page state flags were set by rmqueue().
 *
 * This function does not add the page to the LRU.  The caller must do that.
 */
/**
 * 把一个新页的描述符插入到页高速缓存。
 * 它接收的参数有：页描述符的地址page、address_space对象的地址mapping、表示在地址空间内的页索引的值offset和为基数分配新结点时所使用的内存分配标志gfp_mask
 */
int add_to_page_cache(struct page *page, struct address_space *mapping,
		pgoff_t offset, int gfp_mask)
{
	/**
	 * 调用radix_tree_preload，它禁用内核抢占。并把一些空的radix_tree_node结构赋给每CPU变量radix_tree_preloads。
	 * radix_tree_node结构的分配由slab分配高速缓存radix_tree_node_cachep完成
	 * 如果radix_tree_node_cachep预分配不成功，add_to_page_cache就终止并返回错误-ENOMEM。
	 */
	int error = radix_tree_preload(gfp_mask & ~__GFP_HIGHMEM);

	/*
	 * 如果radix_tree_preload 成功分配节点
	 */
	if (error == 0) {
		/**
		 * 获取tree_lock自旋锁
		 * radix_tree_preload已经禁止了内核抢占。
		 */
		spin_lock_irq(&mapping->tree_lock);
		/**
		 * 调用radix_tree_insert在树中插入新结点
		 */
		error = radix_tree_insert(&mapping->page_tree, offset, page); /*★*/
		if (!error) {
			/**
			 * 增加页描述符的使用计数
			 */
			page_cache_get(page);
			/**
			 * 由于页是新的，所以使其内容无效。函数设置页框的PG_locked标志，以阻止其他内核路径访问该页。
			 */
			SetPageLocked(page);
			/**
			 * 使用mapping 和offset 参数初始化page
			 */
			page->mapping = mapping; /*★*/
			page->index = offset; /*★*/
			mapping->nrpages++;
			/**
			 * 增加地址空间的缓存页的计数器。
			 */
			pagecache_acct(1);
		}
		/**
		 * 释放自旋锁并调用radix_tree_preload_end重新启用内核抢占。
		 */
		spin_unlock_irq(&mapping->tree_lock);
		radix_tree_preload_end(); /*★*/
	}
	return error;
}

EXPORT_SYMBOL(add_to_page_cache);

/**
 * 插入新页描述符到高速缓存中.新页的PG_locked标志被置位.
 * 将新页插入LRU链表中.
 */
int add_to_page_cache_lru(struct page *page, struct address_space *mapping,
				pgoff_t offset, int gfp_mask)
{
    /**
     * 调用add_to_page_cache插入新页描述符到高速缓存中.新页的PG_locked标志被置位.
     */        
	int ret = add_to_page_cache(page, mapping, offset, gfp_mask); /*★*/
	if (ret == 0)
		/*
		 * 调用lru_cache_add，将新页插入LRU链表中.
	     */
		lru_cache_add(page); /*★*/
	return ret;
}

/*
 * In order to wait for pages to become available there must be
 * waitqueues associated with pages. By using a hash table of
 * waitqueues where the bucket discipline is to maintain all
 * waiters on the same queue and wake all when any of the pages
 * become available, and for the woken contexts to check to be
 * sure the appropriate page became available, this saves space
 * at a cost of "thundering herd" phenomena during rare hash
 * collisions.
 */
static wait_queue_head_t *page_waitqueue(struct page *page)
{
	const struct zone *zone = page_zone(page);

	return &zone->wait_table[hash_ptr(page, zone->wait_table_bits)];
}

static inline void wake_up_page(struct page *page, int bit)
{
	__wake_up_bit(page_waitqueue(page), &page->flags, bit);
}

void fastcall wait_on_page_bit(struct page *page, int bit_nr)
{
	DEFINE_WAIT_BIT(wait, &page->flags, bit_nr);

	if (test_bit(bit_nr, &page->flags))
		__wait_on_bit(page_waitqueue(page), &wait, sync_page,
							TASK_UNINTERRUPTIBLE);
}
EXPORT_SYMBOL(wait_on_page_bit);

/**
 * unlock_page() - unlock a locked page
 *
 * @page: the page
 *
 * Unlocks the page and wakes up sleepers in ___wait_on_page_locked().
 * Also wakes sleepers in wait_on_page_writeback() because the wakeup
 * mechananism between PageLocked pages and PageWriteback pages is shared.
 * But that's OK - sleepers in wait_on_page_writeback() just go back to sleep.
 *
 * The first mb is necessary to safely close the critical section opened by the
 * TestSetPageLocked(), the second mb is necessary to enforce ordering between
 * the clear_bit and the read of the waitqueue (to avoid SMP races with a
 * parallel wait_on_page_locked()).
 */
/*
 * 内核使用unlock_page函数对页进行解锁，并唤醒在等待队列上睡眠的进程
 */
void fastcall unlock_page(struct page *page)
{
	smp_mb__before_clear_bit();
	if (!TestClearPageLocked(page)) /*★*/
		BUG();
	smp_mb__after_clear_bit(); 
	wake_up_page(page, PG_locked); /*★*/
}
EXPORT_SYMBOL(unlock_page);

/*
 * End writeback against a page.
 */
void end_page_writeback(struct page *page)
{
	if (!TestClearPageReclaim(page) || rotate_reclaimable_page(page)) {
		if (!test_clear_page_writeback(page))
			BUG();
	}
	smp_mb__after_clear_bit();
	wake_up_page(page, PG_writeback);
}
EXPORT_SYMBOL(end_page_writeback);

/*
 * Get a lock on the page, assuming we need to sleep to get it.
 *
 * Ugly: running sync_page() in state TASK_UNINTERRUPTIBLE is scary.  If some
 * random driver's requestfn sets TASK_RUNNING, we could busywait.  However
 * chances are that on the second loop, the block layer's plug list is empty,
 * so sync_page() will then return in state TASK_UNINTERRUPTIBLE.
 */
void fastcall __lock_page(struct page *page)
{
	DEFINE_WAIT_BIT(wait, &page->flags, PG_locked);

	/*
	 * 如果已经设置了PG_locked，则加入等待队列，把进程设置为TASK_UNINTERRUPTIBLE
	 * 调用sync_page 方法以取消文件所在块设备的请求队列，调用schedule()  函数挂起来
	 * 直到把PG_locked 标志清零。
	 * 内核使用unlock_page 函数对页进行解锁，并唤醒在等待队列上睡眠的进程
	 */
	__wait_on_bit_lock(page_waitqueue(page), &wait, sync_page,
							TASK_UNINTERRUPTIBLE);
}
EXPORT_SYMBOL(__lock_page);

/*
 * a rather lightweight function, finding and getting a reference to a
 * hashed page atomically.
 */
/**
 * 在页高速缓存的基树中查找页
 * @mapping - 指向address_space 对象的指针
 * @offset - 偏移量(也是页索引)
 */
struct page * find_get_page(struct address_space *mapping, unsigned long offset)
{
	struct page *page;

	/**
	 * 先获取基树锁
	 */
	spin_lock_irq(&mapping->tree_lock);
	/**
	 * radix_tree_lookup函数搜索拥有指定偏移量的基树的叶子节点。
	 * 根据偏移量值中的位依次从树根开始向下搜索。如果遇到空指针，则返回NULL。否则，返回叶子节点的地址。
	 */
	page = radix_tree_lookup(&mapping->page_tree, offset);
	/**
	 * 如果找到所需要的页，就增加该页的使用计数器
	 */
	if (page)
		page_cache_get(page);
	/**
	 * 释放基树锁，并返回页地址。
	 */
	spin_unlock_irq(&mapping->tree_lock);
	return page;
}

EXPORT_SYMBOL(find_get_page);

/*
 * Same as above, but trylock it instead of incrementing the count.
 */
/**
 * 与find_lock_page相似，但是当它不会阻塞当前进程。
 */
struct page *find_trylock_page(struct address_space *mapping, unsigned long offset)
{
	struct page *page;

	spin_lock_irq(&mapping->tree_lock);
	page = radix_tree_lookup(&mapping->page_tree, offset); /*★*/
	if (page && TestSetPageLocked(page)) /*★*/
		page = NULL;
	spin_unlock_irq(&mapping->tree_lock);
	return page;
}

EXPORT_SYMBOL(find_trylock_page);

/**
 * find_lock_page - locate, pin and lock a pagecache page
 *
 * @mapping - the address_space to search
 * @offset - the page index
 *
 * Locates the desired pagecache page, locks it, increments its reference
 * count and returns its address.
 *
 * Returns zero if the page was not present. find_lock_page() may sleep.
 */
/**
 * 与find_get_page相似，但是它还会调用lock_page设置页的PG_locked标志。为的是调用者可用以互斥的方式访问这个页面
 */
struct page *find_lock_page(struct address_space *mapping,
				unsigned long offset)
{
	struct page *page;

	spin_lock_irq(&mapping->tree_lock);
repeat:
	page = radix_tree_lookup(&mapping->page_tree, offset); /*★*/
	if (page) {
		page_cache_get(page);
		if (TestSetPageLocked(page)) {/* 已经被其他进程锁住 */
			spin_unlock_irq(&mapping->tree_lock);/* 先释放锁，因为随后的lock_page可能会被调度出来 */
			lock_page(page); /* 锁住页面 */
			spin_lock_irq(&mapping->tree_lock);

			/* Has the page been truncated while we slept? */
			if (page->mapping != mapping || page->index != offset) {/* 确保在睡眠过程中，页面没有发生变化 */
				unlock_page(page);
				page_cache_release(page);
				goto repeat;
			}
		}
	}
	spin_unlock_irq(&mapping->tree_lock);
	return page;
}

EXPORT_SYMBOL(find_lock_page);

/**
 * find_or_create_page - locate or add a pagecache page
 *
 * @mapping - the page's address_space
 * @index - the page's index into the mapping
 * @gfp_mask - page allocation mode
 *
 * Locates a page in the pagecache.  If the page is not present, a new page
 * is allocated using @gfp_mask and is added to the pagecache and to the VM's
 * LRU list.  The returned page is locked and has its reference count
 * incremented.
 *
 * find_or_create_page() may sleep, even if @gfp_flags specifies an atomic
 * allocation!
 *
 * find_or_create_page() returns the desired page's address, or zero on
 * memory exhaustion.
 */
/**
 * 执行find_lock_page，如果找不到所请求的页，就分配一个新页并把它插入到页高速缓存。
 */
struct page *find_or_create_page(struct address_space *mapping,
		unsigned long index, unsigned int gfp_mask)
{
	struct page *page, *cached_page = NULL;
	int err;
repeat:
	page = find_lock_page(mapping, index); /*★*/
	if (!page) { /*如果找不到*/
		if (!cached_page) {
			cached_page = alloc_page(gfp_mask); /*★*/
			if (!cached_page)
				return NULL;
		}
		err = add_to_page_cache_lru(cached_page, mapping,
					index, gfp_mask); /*★*/
		if (!err) {
			page = cached_page;
			cached_page = NULL;
		} else if (err == -EEXIST)
			goto repeat;
	}
	if (cached_page)
		page_cache_release(cached_page);
	return page;
}

EXPORT_SYMBOL(find_or_create_page);

/**
 * find_get_pages - gang pagecache lookup
 * @mapping:	The address_space to search
 * @start:	The starting page index
 * @nr_pages:	The maximum number of pages
 * @pages:	Where the resulting pages are placed
 *
 * find_get_pages() will search for and return a group of up to
 * @nr_pages pages in the mapping.  The pages are placed at @pages.
 * find_get_pages() takes a reference against the returned pages.
 *
 * The search returns a group of mapping-contiguous pages with ascending
 * indexes.  There may be holes in the indices due to not-present pages.
 *
 * find_get_pages() returns the number of pages which were found.
 */
/**
 * 与find_get_page相似，但是它在高速缓存中查找一组具有相邻索引的页。
 * mapping:		在mapping的基树中查找
 * start:		地址空间中相对于搜索起始位置的偏移量。也就是第一个要搜索的page index
 * nr_pages:	所检索到页的最大数量
 * pages:		存放检索到的页。
 */
unsigned find_get_pages(struct address_space *mapping, pgoff_t start,
			    unsigned int nr_pages, struct page **pages)
{
	unsigned int i;
	unsigned int ret;

	spin_lock_irq(&mapping->tree_lock);
	/**
	 * radix_tree_gang_lookup实现真正的查找操作，它为指针数组赋值并返回找到的页数。
	 * 由于一些页可能不在页高速缓存中，所以结果中会出现空缺的页索引，但是返回的页的索引值是递增的。
	 */
	ret = radix_tree_gang_lookup(&mapping->page_tree,
				(void **)pages, start, nr_pages);
	for (i = 0; i < ret; i++)
		page_cache_get(pages[i]);
	spin_unlock_irq(&mapping->tree_lock);
	return ret;
}

/*
 * Like find_get_pages, except we only return pages which are tagged with
 * `tag'.   We update *index to index the next page for the traversal.
 */
/**
 * 与find_get_pages类似，但是返回的只是那些用tag参数标记的页。
 * 这个函数对于快速找到一个索引节点的所有脏页是非常关键的。
 */
unsigned find_get_pages_tag(struct address_space *mapping, pgoff_t *index,
			int tag, unsigned int nr_pages, struct page **pages)
{
	unsigned int i;
	unsigned int ret;

	spin_lock_irq(&mapping->tree_lock);
	ret = radix_tree_gang_lookup_tag(&mapping->page_tree,
				(void **)pages, *index, nr_pages, tag);
	for (i = 0; i < ret; i++)
		page_cache_get(pages[i]);
	if (ret)
		*index = pages[ret - 1]->index + 1;
	spin_unlock_irq(&mapping->tree_lock);
	return ret;
}

/*
 * Same as grab_cache_page, but do not wait if the page is unavailable.
 * This is intended for speculative data generators, where the data can
 * be regenerated if the page couldn't be grabbed.  This routine should
 * be safe to call while holding the lock for another page.
 *
 * Clear __GFP_FS when allocating the page to avoid recursion into the fs
 * and deadlock against the caller's locked page.
 */
struct page *
grab_cache_page_nowait(struct address_space *mapping, unsigned long index)
{
	struct page *page = find_get_page(mapping, index);
	int gfp_mask;

	if (page) {
		if (!TestSetPageLocked(page))
			return page;
		page_cache_release(page);
		return NULL;
	}
	gfp_mask = mapping_gfp_mask(mapping) & ~__GFP_FS;
	page = alloc_pages(gfp_mask, 0);
	if (page && add_to_page_cache_lru(page, mapping, index, gfp_mask)) {
		page_cache_release(page);
		page = NULL;
	}
	return page;
}

EXPORT_SYMBOL(grab_cache_page_nowait);

/*
 * This is a generic file read routine, and uses the
 * mapping->a_ops->readpage() function for the actual low-level
 * stuff.
 *
 * This is really ugly. But the goto's actually try to clarify some
 * of the logic when it comes to error handling etc.
 *
 * Note the struct file* is only passed for the use of readpage.  It may be
 * NULL.
 */
/**
 * 从磁盘读入所请求的页,并把它们复制到用户态缓冲区.被do_generic_file_read调用
 */
void do_generic_mapping_read(struct address_space *mapping,
			     struct file_ra_state *_ra,
			     struct file *filp,
			     loff_t *ppos,
			     read_descriptor_t *desc,
			     read_actor_t actor)
{
	/**
	 * 获得地址空间对象的所有者，即索引节点对象，它将拥有填充了文件数据的页面，它的地址存放在address_space对象的host字段中。
	 * 如果所读文件是块设备文件，那么所有者就不是由filep->f_dentry->d_inode指向的索引节点对象，而是bdev特殊文件系统中的索引节点对象
	 */
	struct inode *inode = mapping->host;
	unsigned long index;
	unsigned long end_index;
	unsigned long offset;
	unsigned long req_size;
	unsigned long next_index;
	unsigned long prev_index;
	loff_t isize;
	struct page *cached_page;
	int error;
	struct file_ra_state ra = *_ra;

	cached_page = NULL;
	/*
	 * 把文件系统看做细分的数据页(每页4K字节)
	 */
	/**
	 * 从文件指针*ppos导出第一个请求字节所在页的逻辑号,即地址空间中的页索引,并存放在index变量中
	 */
	index = *ppos >> PAGE_CACHE_SHIFT; 
	next_index = index;
	prev_index = ra.prev_page;
	req_size = (desc->count + PAGE_CACHE_SIZE - 1) >> PAGE_CACHE_SHIFT;
	/**
	 * 也把第一个请求字节在页内的偏移量存放在offset局部变量中.
	 */
	offset = *ppos & ~PAGE_CACHE_MASK;

	isize = i_size_read(inode);
	if (!isize)
		goto out;

	end_index = (isize - 1) >> PAGE_CACHE_SHIFT; //end_index表示最后一个页面的索引号
	/**
	 * 开始一个循环来读取包含请求字节的所有页，要读取数据的字节存放desc->count中.
	 */
	for (;;) {
		struct page *page;
		unsigned long ret_size, nr, ret;

		/* nr is the maximum number of bytes to copy from this page */
		/**
		 * 如果index*4096+offset超过存放索引节点对象的i_size字段中的文件大小，则退出循环
		 * 
		 * 将应复制到用户态缓冲区的页中的字节数存放在nr中,它应该是4096.除非offset!=0或者请求的数据不全在文件中.
		 */
		nr = PAGE_CACHE_SIZE;
		/**
		 * 超过了索引节点对象的文件大小字段,则从循环中退出.
		 */		
		if (index >= end_index) {
			/*
			 * 超过了，index在end_index之后
			 */
			if (index > end_index)
				goto out;
		    /*
		     * index等于end_index，正好最后一个
		     * nr是文件所有的字节数，对PAGE_SIZE向下取整, 取得最后一页中的字节数
			 */
			nr = ((isize - 1) & ~PAGE_CACHE_MASK) + 1; //
			/*
			 * offset超过最后一个页面的字节数，也是超出了文件的范围
			 */
			if (nr <= offset) {
				goto out;
			}
		}
		/*
		 * offset后剩下的字节数，nr现在为偏移量之后还剩下需要读取的字节数
		 */
		nr = nr - offset;

		/**
		 * 如果当前进程的TIF_NEED_RESCHED,如果置位,就进行一次调度.
		 */
		cond_resched();
		/**
		 * 如果有预读的页,就调用page_cache_readahead读入这些页面
		 */
		if (index == next_index && req_size) {
			ret_size = page_cache_readahead(mapping, &ra,
					filp, index, req_size); /*★*/
			next_index += ret_size;
			req_size -= ret_size;
		}

find_page:
		/**
		 * 调用find_get_page查找页高速缓存以找到包含所请求数据的页描述符.
		 */
		page = find_get_page(mapping, index); /*★*/
		/**
		 * page==NULL表示所请求的页不在高速缓存中
		 */
		if (unlikely(page == NULL)) {
			/**
			 * 调用handle_ra_miss调整预读参数.
			 */
			handle_ra_miss(mapping, &ra, index); /*★*/
			/*
			 * 跳转到no_cached_page标记处
			 */
			goto no_cached_page;
		}

		/**
		 * 运行到此,说明页已经位于页高速缓存中,检查标志PG_uptodate.
		 * 如果置位,表示页所存数据是最新的,因此无需从磁盘中读入数据.
		 * 如果没有置位，跳转到page_not_up_to_date
		 */
		if (!PageUptodate(page))
			goto page_not_up_to_date;
page_ok:

		/* If users can be writing to this page using arbitrary
		 * virtual addresses, take care about potential aliasing
		 * before reading the page on the kernel side.
		 */
		/**
		 * 运行到此,表示页已经位于高速缓存中,并且是最新的.
		 * 或者说已经正确的读到高速缓存中了.无需从磁盘中读入数据.
		 */

		if (mapping_writably_mapped(mapping))
			flush_dcache_page(page);

		/*
		 * When (part of) the same page is read multiple times
		 * in succession, only mark it as accessed the first time.
		 */
		/**
		 * 调用mark_page_accessed标记PG_referenced或PG_active,从而表示该页正被访问并且不应该被换出.
		 * 如果同一文件在do_generic_file_read的后续执行中要读几次,那么这个过程只需要被调用一次.
		 * 通过prev_index来进行判定是否是第一次读取
		 */
		if (prev_index != index)
			mark_page_accessed(page);
		prev_index = index;

		/*
		 * Ok, we have the page, and it's up-to-date, so
		 * now we can copy it to user space...
		 *
		 * The actor routine returns how many bytes were actually used..
		 * NOTE! This may not be the same as how much of a user buffer
		 * we filled up (we may be padding etc), so we can only update
		 * "pos" here (the actor routine has to update the user buffer
		 * pointers and the remaining count).
		 */
		/*
		 * 现在到了把页中的数据拷贝到用户态缓冲区的时候了，为了这么做，调用file_read_actor()函数
		 */
		/**
		 * actor是传递进来的参数,它一般是file_read_actor函数.
		 * 该函数的作用是把页中的数据复制到用户态缓冲区中.
		 */
		ret = actor(desc, page, offset, nr); /*★*/
		/**
		 * 根据传入的用户态缓冲区的有效字节数来更新局部变量index和count。
		 * 一般情况下,如果是最后一个字节已经拷贝到用户态缓冲区，那么index加1而offset清0
		 * 否则index的值不变,offset的值加上ret，即已拷贝到用户态缓冲区的字节数
		 */
		offset += ret;
		index += offset >> PAGE_CACHE_SHIFT;
		offset &= ~PAGE_CACHE_MASK;

		/**
		 * 减少页描述符的引用计数器.
		 */
		page_cache_release(page);
		/**
		 * desc->count != 0表示还有数据要读,那就继续循环处理
		 */
		if (ret == nr && desc->count)
			continue;
		goto out;

page_not_up_to_date:
		/* Get exclusive access to the page ... */
		/**
		 * 运行到此,说明页虽然在高速缓存中,但是其数据是脏的.也必须从磁盘中读取.
		 */

		/**
		 * 调用lock_page获取对页的互斥访问.如果PG_locked已经置位,则lock_page会阻塞进程,直到标志被清0.
		 */
		lock_page(page);

		/* Did it get unhashed before we got the lock? */
		/**
		 * 虽然现在获得了对页的锁定,但是上一个进程可能在解除锁定前,已经将页从高速缓存中删除了
		 * 所以需要检查mapping字段,如果为NULL,表示已经删除,就解除锁定,减少引用计数,并重新读这一页.
		 */
		if (!page->mapping) {
			unlock_page(page);
			page_cache_release(page);
			continue;
		}

		/* Did somebody else fill it already? */
		/**
		 * 函数运行到此,说明页已经被锁定,并且在高速缓存中.
		 * 再次检查PG_uptodate,如果该标志置位,调用unlock_page并跳过读操作(呵呵,这种事情最好不过了,有人代劳了)
		 * 跳转至page_ok
		 */
		if (PageUptodate(page)) {
			unlock_page(page);
			goto page_ok;
		}

readpage:
		/* Start the actual read. The read will unlock the page. */
		/**
		 * 现在真正的IO操作可以开始了
		 * 调用address_space对象的readpage方法
		 * 这才是开始真正的IO操作.它会激活磁盘到页之间的IO数据传输.
		 */
		error = mapping->a_ops->readpage(filp, page); /*★*/

		if (unlikely(error))
			goto readpage_error;
		/**
		 * 如果PG_uptodate还没有被置位,则调用lock_page,等待页被有效读入.
		 * 一旦读取操作完成后就被解锁。因此当前进程在IO数据传输完成是才停止休眠了
		 * 这里的lock_page起了同步信号量的作用
		 */
		if (!PageUptodate(page)) {
			lock_page(page);
			if (!PageUptodate(page)) {
				if (page->mapping == NULL) {
					/*
					 * invalidate_inode_pages got it
					 */
					unlock_page(page);
					page_cache_release(page);
					goto find_page;
				}
				unlock_page(page);
				error = -EIO;
				goto readpage_error;
			}
			unlock_page(page);
		}

		/*
		 * i_size must be checked after we have done ->readpage.
		 *
		 * Checking i_size after the readpage allows us to calculate
		 * the correct value for "nr", which means the zero-filled
		 * part of the page is not copied back to userspace (unless
		 * another truncate extends the file - this is desired though).
		 */
		isize = i_size_read(inode);
		end_index = (isize - 1) >> PAGE_CACHE_SHIFT;
		/**
		 * 页超过文件所包含的页数,就减少页计数器.则跳转到out标记处
		 * 这种情况发生在正被本程序读的文件同时有其他进程正在删减.
		 */
		if (unlikely(!isize || index > end_index)) {
			page_cache_release(page);
			goto out;
		}

		/* nr is the maximum number of bytes to copy from this page */
		/**
		 * 计算应复制到用户态缓冲区的字节数,存放在局部变量nr中.一般应该是4096，
		 * 除非offset非0(这只发生在读请求书的首尾页时)或请求数据不全在文件中
		 */
		nr = PAGE_CACHE_SIZE;
		if (index == end_index) {
			nr = ((isize - 1) & ~PAGE_CACHE_MASK) + 1; //如果是最后一页，那么nr最后一页中的字节数
			if (nr <= offset) {
				page_cache_release(page);
				goto out;
			}
		}
		nr = nr - offset; /*文件中剩下的字节数*/
		goto page_ok;

readpage_error:
		/* UHHUH! A synchronous read error occurred. Report it */
		desc->error = error;
		page_cache_release(page);
		goto out;

no_cached_page:
		/*
		 * Ok, it wasn't cached, so we need to create a new
		 * page..
		 */
		/**
		 * 要读的页不在缓存中
		 */
		if (!cached_page) {
			/**
			 * 分配一个新页
			 */
			cached_page = page_cache_alloc_cold(mapping); /*★*/
			if (!cached_page) {
				desc->error = -ENOMEM;
				goto out;
			}
		}
		/**
		 * 插入新页描述符到高速缓存中.新页的PG_locked标志被置位.
		 * 将新页插入LRU链表中.
		 */
		error = add_to_page_cache_lru(cached_page, mapping,
						index, GFP_KERNEL);
		if (error) {
			if (error == -EEXIST)
				goto find_page;
			desc->error = error;
			goto out;
		}
		page = cached_page;
		cached_page = NULL;
		/**
		 * 跳转到readpage标记处，开始读文件数据.
		 */
		goto readpage;
	}

out:
	/**
	 * 所有请求的或者说可以读到的数据已经读完,就更新预读数据结构filp->f_ra来标记数据已经被顺序从文件读入(参见文件预读).
	 */	
	*_ra = ra;

	/**
	 * 把index*4096+offset值赋给*ppos,从而保存以后调用read()和write()进行顺序访问的位置
	 * 保存ppos,以后read或者write就会从这个位置开始.
	 */
	*ppos = ((loff_t) index << PAGE_CACHE_SHIFT) + offset;
	if (cached_page)
		page_cache_release(cached_page);
	/**
	 * 调用update_atime把当前时间存放在文件索引节点的i_atime字段中,并把它标记为脏后返回
	 */
	if (filp)
		file_accessed(filp);
}

EXPORT_SYMBOL(do_generic_mapping_read);

/**
 * 将页中的数据复制到用户态缓冲区.
 */
int file_read_actor(read_descriptor_t *desc, struct page *page,
			unsigned long offset, unsigned long size)
{
	char *kaddr;
	unsigned long left, count = desc->count;

	if (size > count)
		size = count;

	/*
	 * Faults on the destination of a read are common, so do it before
	 * taking the kmap.
	 */
	if (!fault_in_pages_writeable(desc->arg.buf, size)) {
		kaddr = kmap_atomic(page, KM_USER0);
		left = __copy_to_user_inatomic(desc->arg.buf,
						kaddr + offset, size);
		kunmap_atomic(kaddr, KM_USER0);
		if (left == 0)
			goto success;
	}

	/* Do it the slow way */
	/**
	 * kmap为处于高端内存中的页建立永久的内核映射.
	 */
	kaddr = kmap(page);
	/**
	 * 复制页中的数据到用户态空间.
	 */
	left = __copy_to_user(desc->arg.buf, kaddr + offset, size);
	/**
	 * 调用kunmap释放页的永久内核映射
	 */
	kunmap(page);

	if (left) {
		size -= left;
		desc->error = -EFAULT;
	}
success:
	/**
	 * 更新read_descriptor_t的字段.
	 */
	desc->count = count - size;
	desc->written += size;
	desc->arg.buf += size;
	return size;
}

/*
 * This is the "read()" routine for all filesystems
 * that can use the page cache directly.
 */
/**
 * 所有文件系统实现同步和异步读操作使用的通用例程。
 * 最常见的情形: 即对页高速缓存文件的系统调用read()所引发的同步操作
 * iocb:		控制参数,kiocb描述符地址
 * iov:			iovec描述符数组地址。iovec描述符数组被函数generic_file_read调用时只有一个元素，该元素描述待接收数据的用户态缓冲区。
 * nr_segs:		iovec描述符数组长度。
 * ppos:		文件当前指针变量。
 */
ssize_t
__generic_file_aio_read(struct kiocb *iocb, const struct iovec *iov,
		unsigned long nr_segs, loff_t *ppos)
{
	struct file *filp = iocb->ki_filp;
	ssize_t retval;
	unsigned long seg;
	size_t count;

	count = 0;
	/**
	 * 调用access_ok来检查iovec描述符所描述的用户态缓冲区是否有效。如果无效返回-EFAULT
	 */
	for (seg = 0; seg < nr_segs; seg++) {
		const struct iovec *iv = &iov[seg];

		/*
		 * If any segment has a negative length, or the cumulative
		 * length ever wraps negative then return -EINVAL.
		 */
		count += iv->iov_len;
		if (unlikely((ssize_t)(count|iv->iov_len) < 0))
			return -EINVAL;
		if (access_ok(VERIFY_WRITE, iv->iov_base, iv->iov_len))
			continue;
		if (seg == 0)
			return -EFAULT;
		nr_segs = seg;
		count -= iv->iov_len;	/* This segment is no good */
		break;
	}

	/* coalesce the iovecs and go direct-to-BIO for O_DIRECT */
	/*
	 * 处理直接IO ,等效于如下代码
	 *
         if (filp->f_flags & O_DIRECT) {
             if (count == 0 || *ppos > filp->f_mapping->host->i_size)
                 return 0;
             retval = generic_file_direct_IO(READ, iocb, iov, *ppos, 1);
             if (retval > 0)
                 *ppos += retval;
             file_accessed(filp);
             return retval;
         }
     
	 *
     */
	if (filp->f_flags & O_DIRECT) {
		loff_t pos = *ppos, size;
		struct address_space *mapping;
		struct inode *inode;

		mapping = filp->f_mapping;
		inode = mapping->host;
		retval = 0;
		if (!count)
			goto out; /* skip atime */
		size = i_size_read(inode);
		if (pos < size) {
			/* 将缓冲区写入磁盘后再进行直接IO */
			retval = generic_file_direct_IO(READ, iocb,
						iov, pos, nr_segs); /*★*/
			if (retval >= 0 && !is_sync_kiocb(iocb))
				retval = -EIOCBQUEUED;
			if (retval > 0)
				*ppos = pos + retval;
		}
		file_accessed(filp); /*★*/
		goto out;
	}

	retval = 0;
	if (count) {
		/* 遍历处理每一个段 */
		for (seg = 0; seg < nr_segs; seg++) {
			/**
			 * 为每个读缓冲区建立一个读操作描述符。
			 * 该结构存放与单个用户态缓冲区相关的文件读操作的当前状态。
			 */
			read_descriptor_t desc;

			desc.written = 0;
			desc.arg.buf = iov[seg].iov_base;
			desc.count = iov[seg].iov_len;
			if (desc.count == 0)
				continue;
			desc.error = 0;
			/**
			 * 调用do_generic_file_read，从磁盘读入所请求的页并把它们拷贝到用户态缓冲区。
			 */
			do_generic_file_read(filp,ppos,&desc,file_read_actor);
			/*
			 * 返回拷贝到用户态缓冲区的字节数，即read_descriptor_t的written值
			 */
			retval += desc.written;
			if (!retval) {
				retval = desc.error;
				break;
			}
		}
	}
out:
	return retval;
}

EXPORT_SYMBOL(__generic_file_aio_read);

ssize_t
generic_file_aio_read(struct kiocb *iocb, char __user *buf, size_t count, loff_t pos)
{
	struct iovec local_iov = { .iov_base = buf, .iov_len = count };

	BUG_ON(iocb->ki_pos != pos);
	return __generic_file_aio_read(iocb, &local_iov, 1, &iocb->ki_pos);
}

EXPORT_SYMBOL(generic_file_aio_read);

/**
 * 读取大部分磁盘文件系统中的普通文件及任何块设备文件。
 * 实现了几乎所有磁盘文件系统中的普通文件及任何块文件的read方法
 * filp:	文件对象的地址。
 * buf:		用户态线性区的线性地址。
 * count:	要读取的字符个数。
 * ppos:	指向一个变量的指针，该变量存放读操作开始处的文件偏移量。通常是filp的f_pos字段。
 */
ssize_t
generic_file_read(struct file *filp, char __user *buf, size_t count, loff_t *ppos)
{
	/**
	 * 初始化两个描述符
	 * (1) 初始化iovec，该描述符包含用户态缓冲区的地址与长度。
	 */
	struct iovec local_iov = { .iov_base = buf, .iov_len = count };
	struct kiocb kiocb;
	ssize_t ret;

	/**
	 * (2) 调用init_sync_kiocb初始化kiocb，该描述符用来跟踪正在运行的同步和异步IO操作的完成状态。
	 */
	init_sync_kiocb(&kiocb, filp);
	/**
	 * 调用__generic_file_aio_read,并将kiocb和iovec传递给他
	 * __generic_file_aio_read根据两个描述符从文件中读取数据。
	 * 并将读入的有效字符数返回。
	 */
	ret = __generic_file_aio_read(&kiocb, &local_iov, 1, ppos); /*★*/
	if (-EIOCBQUEUED == ret)
		ret = wait_on_sync_kiocb(&kiocb);
	/*返回读取的字节数*/
	return ret;
}

EXPORT_SYMBOL(generic_file_read);

int file_send_actor(read_descriptor_t * desc, struct page *page, unsigned long offset, unsigned long size)
{
	ssize_t written;
	unsigned long count = desc->count;
	struct file *file = desc->arg.data;

	if (size > count)
		size = count;

	written = file->f_op->sendpage(file, page, offset,
				       size, &file->f_pos, size<count);
	if (written < 0) {
		desc->error = written;
		written = 0;
	}
	desc->count = count - written;
	desc->written += written;
	return written;
}

ssize_t generic_file_sendfile(struct file *in_file, loff_t *ppos,
			 size_t count, read_actor_t actor, void *target)
{
	read_descriptor_t desc;

	if (!count)
		return 0;

	desc.written = 0;
	desc.count = count;
	desc.arg.data = target;
	desc.error = 0;

	do_generic_file_read(in_file, ppos, &desc, actor);
	if (desc.written)
		return desc.written;
	return desc.error;
}

EXPORT_SYMBOL(generic_file_sendfile);

static ssize_t
do_readahead(struct address_space *mapping, struct file *filp,
	     unsigned long index, unsigned long nr)
{
	if (!mapping || !mapping->a_ops || !mapping->a_ops->readpage)
		return -EINVAL;

	force_page_cache_readahead(mapping, filp, index,
					max_sane_readahead(nr));
	return 0;
}

asmlinkage ssize_t sys_readahead(int fd, loff_t offset, size_t count)
{
	ssize_t ret;
	struct file *file;

	ret = -EBADF;
	file = fget(fd);
	if (file) {
		if (file->f_mode & FMODE_READ) {
			struct address_space *mapping = file->f_mapping;
			unsigned long start = offset >> PAGE_CACHE_SHIFT;
			unsigned long end = (offset + count - 1) >> PAGE_CACHE_SHIFT;
			unsigned long len = end - start + 1;
			ret = do_readahead(mapping, file, start, len);
		}
		fput(file);
	}
	return ret;
}

#ifdef CONFIG_MMU
/*
 * This adds the requested page to the page cache if it isn't already there,
 * and schedules an I/O to read in its contents from disk.
 */
static int FASTCALL(page_cache_read(struct file * file, unsigned long offset));
static int fastcall page_cache_read(struct file * file, unsigned long offset)
{
	struct address_space *mapping = file->f_mapping;
	struct page *page; 
	int error;

	page = page_cache_alloc_cold(mapping);
	if (!page)
		return -ENOMEM;

	error = add_to_page_cache_lru(page, mapping, offset, GFP_KERNEL);
	if (!error) {
		error = mapping->a_ops->readpage(file, page);
		page_cache_release(page);
		return error;
	}

	/*
	 * We arrive here in the unlikely event that someone 
	 * raced with us and added our page to the cache first
	 * or we are out of memory for radix-tree nodes.
	 */
	page_cache_release(page);
	return error == -EEXIST ? 0 : error; /*注意: 返回值0表示失败，非零表示成功*/
}

#define MMAP_LOTSAMISS  (100)

/*
 * filemap_nopage() is invoked via the vma operations vector for a
 * mapped memory region to read in file data during a page fault.
 *
 * The goto's are kind of ugly, but this streamlines the normal case of having
 * it in the page cache, and handles the special cases reasonably without
 * having a lot of duplicated code.
 */
/**
 * 几乎所有文件系统和块设备文件都通过本方法实现内存映射的nopage方法。
 * 必须首先在页高速缓存中查找所请求的页。如果没有找到相应的页，这个方法就必须将其从磁盘上读入。
 * 		area:		所请求页所在线性区的描述符地址。
 * 		address:	所请求页的线性地址。
 * 		type:		存放函数侦测到的缺页类型(VM_FAULT_MAJOR或者VM_FAULT_MINOR)的变量的指针。
 */
struct page * filemap_nopage(struct vm_area_struct * area, unsigned long address, int *type)
{
	int error;
	/**
	 * 从area得到文件对象地址，address_space对象地址，索引节点对象地址。
	 */
	struct file *file = area->vm_file;
	struct address_space *mapping = file->f_mapping;
	struct file_ra_state *ra = &file->f_ra;
	struct inode *inode = mapping->host;
	struct page *page;
	unsigned long size, pgoff, endoff;
	int did_readaround = 0, majmin = VM_FAULT_MINOR;

	/**
	 * 根据vm_start和vm_pgoff来确定从address开始的页对应的数据在文件中的偏移量。
	 */
	pgoff = ((address - area->vm_start) >> PAGE_CACHE_SHIFT) + area->vm_pgoff;
	endoff = ((area->vm_end - area->vm_start) >> PAGE_CACHE_SHIFT) + area->vm_pgoff;

retry_all:
	size = (i_size_read(inode) + PAGE_CACHE_SIZE - 1) >> PAGE_CACHE_SHIFT;
	/**
	 * 如果文件偏移量大于文件大小。如果是，就返回NULL。这表示分配新页失败。
	 * 除非缺页是由调试程序通过ptrace系统调用跟踪另一个进程引起的。这也是outside_data_content进行了current->mm == area->mm的原因。
	 */
	if (pgoff >= size)
		goto outside_data_content;

	/* If we don't want any read-ahead, don't bother */
	/**
	 * 如果线性区的VM_RAND_READ标志被设置。则假定进程以随机方式读内存映射中的页，则忽略预读。
	 */
	if (VM_RandomReadHint(area))
		goto no_cached_page;

	/*
	 * The "size" of the file, as far as mmap is concerned, isn't bigger
	 * than the mapping
	 */
	if (size > endoff)
		size = endoff;

	/*
	 * The readahead code wants to be told about each and every page
	 * so it can build and shrink its windows appropriately
	 *
	 * For sequential accesses, we use the generic readahead logic.
	 */
	/**
	 * 文件设置了VM_SEQ_READ，那么需要处理预读。
	 */
	if (VM_SequentialReadHint(area))
		page_cache_readahead(mapping, ra, file, pgoff, 1);

	/*
	 * Do we have something in the page cache already?
	 */
retry_find:
	/**
	 * 调用find_get_page在页高速缓存内寻找由address_space对象和文件偏移量标识的页。
	 */
	page = find_get_page(mapping, pgoff);
	/**
	 * 在页高速缓存中没有找到对应的页。
	 */
	if (!page) {
		unsigned long ra_pages;

		/**
		 * 如果运行到此，说明没有在页高速缓存内找到页，则检查VM_SEQ_READ标志。
		 */
		if (VM_SequentialReadHint(area)) {
			/**
			 * 如果该标志置位，并且页没有在缓存中，说明预读算法失败，内核会强行预读线性区中的页。
			 * 调用handle_ra_miss来调整预读参数。
			 */
			handle_ra_miss(mapping, ra, pgoff);
			goto no_cached_page;
		}

		/**
		 * 没有设置VM_SEQ_READ标志，则将文件file_ra_state描述符中的mmap_miss计数器加1.
		 */
		ra->mmap_miss++;

		/*
		 * Do we miss much more than hit in this file? If so,
		 * stop bothering with read-ahead. It will only hurt.
		 */
		/**
		 * 如果失败数远大于命中数，则忽略预读。
		 */
		if (ra->mmap_miss > ra->mmap_hit + MMAP_LOTSAMISS)
			goto no_cached_page;

		/*
		 * To keep the pgmajfault counter straight, we need to
		 * check did_readaround, as this is an inner loop.
		 */
		if (!did_readaround) {
			majmin = VM_FAULT_MAJOR;
			inc_page_state(pgmajfault);
		}
		did_readaround = 1;
		ra_pages = max_sane_readahead(file->f_ra.ra_pages);
		/**
		 * 如果ra_pages大于0，表示预读没有永久禁止
		 */
		if (ra_pages) {
			pgoff_t start = 0;

			if (pgoff > ra_pages / 2)
				start = pgoff - ra_pages / 2;
			/**
			 * 调用do_page_cache_readahead读入围绕请求页前后的一组页。
			 */
			do_page_cache_readahead(mapping, file, start, ra_pages);
		}
		/**
		 * 再次调用find_get_page在页高速缓存中查找页。
		 */
		page = find_get_page(mapping, pgoff);
		if (!page)
			goto no_cached_page;
	}

	/**
	 * 请求页已经在页高速缓存中，将mmap_hit计数器加1.
	 */
	if (!did_readaround)
		ra->mmap_hit++;

	/*
	 * Ok, found a page in the page cache, now we need to check
	 * that it's up-to-date.
	 */
	/**
	 * 页不是最新的。
	 */
	if (!PageUptodate(page))
		goto page_not_uptodate;

success:
	/*
	 * Found the page and have a reference on it.
	 */
	/**
	 * 标记请求页的访问标志。
	 */
	mark_page_accessed(page);
	/**
	 * type表示是在页高速缓存中，还是从磁盘中找到页面的最新版。
	 * 如果在页高速缓存中找到该页的最新版，将*type设置为VM_FAULT_MINOR，否则设置为VM_FAULT_MAJOR
	 */
	if (type)
		*type = majmin;
	/**
	 * 返回请求页地址。
	 */
	return page;

outside_data_content:
	/*
	 * An external ptracer can access pages that normally aren't
	 * accessible..
	 */
	if (area->vm_mm == current->mm)
		return NULL;
	/* Fall through to the non-read-ahead case */
no_cached_page:
	/*
	 * We're only likely to ever get here if MADV_RANDOM is in
	 * effect.
	 */
	/**
	 * 在页高速缓存中没有找到页，则调用page_cache_read。
	 * 该函数检查请求页是否在页高速缓存中，如果不在，则分配一个新页框，把它追加到页调整缓存。
	 * 执行mapping->a_ops->readpage方法，安排一个IO操作从磁盘读入该页内容。
	 *
	 * 这里只读入一页，即映射的当前页，没有进行预读
	 */
	error = page_cache_read(file, pgoff); /*★*/
	/**
	 * grab_swap_token尽可能为当前进程分配一个交换标记。
	 */
	grab_swap_token(); /*★*/

	/*
	 * The page we want has now been added to the page cache.
	 * In the unlikely event that someone removed it in the
	 * meantime, we'll just come back here and read it again.
	 */
	if (error >= 0)
		goto retry_find; /*★*/

	/*
	 * An error return from page_cache_read can result if the
	 * system is low on memory, or a problem occurs while trying
	 * to schedule I/O.
	 */
	if (error == -ENOMEM)
		return NOPAGE_OOM;
	return NULL;

/**
 * 页不是最新的。
 */
page_not_uptodate:
	if (!did_readaround) {
		majmin = VM_FAULT_MAJOR;
		inc_page_state(pgmajfault);
	}
	/**
	 * 先锁定该页。并触发IO数据传输，然后等待传输完成。
	 */
	lock_page(page);

	/* Did it get unhashed while we waited for it? */
	if (!page->mapping) {
		unlock_page(page);
		page_cache_release(page);
		goto retry_all;
	}

	/* Did somebody else get it up-to-date? */
	/**
	 * 如果其他进程抢占了本进程，并将页面读入了，就不用再次进行IO传输了。
	 */
	if (PageUptodate(page)) {
		unlock_page(page);
		goto success;
	}

	/**
	 * 调用readpage回调函数触发IO数据传输。
	 */
	if (!mapping->a_ops->readpage(file, page)) { /*★*/
		/**
		 * 等待页面传输完毕。
		 */
		wait_on_page_locked(page);
		if (PageUptodate(page))
			goto success; /*★*/
	}

	/*
	 * Umm, take care of errors if the page isn't up-to-date.
	 * Try to re-read it _once_. We do this synchronously,
	 * because there really aren't any performance issues here
	 * and we need to check for errors.
	 */
	lock_page(page);

	/* Somebody truncated the page on us? */
	if (!page->mapping) {
		unlock_page(page);
		page_cache_release(page);
		goto retry_all;
	}

	/* Somebody else successfully read it in? */
	if (PageUptodate(page)) {
		unlock_page(page);
		goto success;
	}
	ClearPageError(page);
	if (!mapping->a_ops->readpage(file, page)) {
		wait_on_page_locked(page);
		if (PageUptodate(page))
			goto success;
	}

	/*
	 * Things didn't work out. Return zero to tell the
	 * mm layer so, possibly freeing the page cache page first.
	 */
	page_cache_release(page);
	return NULL;
}

EXPORT_SYMBOL(filemap_nopage);

static struct page * filemap_getpage(struct file *file, unsigned long pgoff,
					int nonblock)
{
	struct address_space *mapping = file->f_mapping;
	struct page *page;
	int error;

	/*
	 * Do we have something in the page cache already?
	 */
retry_find:
	page = find_get_page(mapping, pgoff);
	if (!page) {
		if (nonblock)
			return NULL;
		goto no_cached_page;
	}

	/*
	 * Ok, found a page in the page cache, now we need to check
	 * that it's up-to-date.
	 */
	if (!PageUptodate(page))
		goto page_not_uptodate;

success:
	/*
	 * Found the page and have a reference on it.
	 */
	mark_page_accessed(page);
	return page;

no_cached_page:
	error = page_cache_read(file, pgoff);

	/*
	 * The page we want has now been added to the page cache.
	 * In the unlikely event that someone removed it in the
	 * meantime, we'll just come back here and read it again.
	 */
	if (error >= 0)
		goto retry_find;

	/*
	 * An error return from page_cache_read can result if the
	 * system is low on memory, or a problem occurs while trying
	 * to schedule I/O.
	 */
	return NULL;

page_not_uptodate:
	lock_page(page);

	/* Did it get unhashed while we waited for it? */
	if (!page->mapping) {
		unlock_page(page);
		goto err;
	}

	/* Did somebody else get it up-to-date? */
	if (PageUptodate(page)) {
		unlock_page(page);
		goto success;
	}

	if (!mapping->a_ops->readpage(file, page)) {
		wait_on_page_locked(page);
		if (PageUptodate(page))
			goto success;
	}

	/*
	 * Umm, take care of errors if the page isn't up-to-date.
	 * Try to re-read it _once_. We do this synchronously,
	 * because there really aren't any performance issues here
	 * and we need to check for errors.
	 */
	lock_page(page);

	/* Somebody truncated the page on us? */
	if (!page->mapping) {
		unlock_page(page);
		goto err;
	}
	/* Somebody else successfully read it in? */
	if (PageUptodate(page)) {
		unlock_page(page);
		goto success;
	}

	ClearPageError(page);
	if (!mapping->a_ops->readpage(file, page)) {
		wait_on_page_locked(page);
		if (PageUptodate(page))
			goto success;
	}

	/*
	 * Things didn't work out. Return zero to tell the
	 * mm layer so, possibly freeing the page cache page first.
	 */
err:
	page_cache_release(page);

	return NULL;
}

/** 
 * 普通文件的populate方法
 */
int filemap_populate(struct vm_area_struct *vma, unsigned long addr,
		unsigned long len, pgprot_t prot, unsigned long pgoff,
		int nonblock)
{
	struct file *file = vma->vm_file;
	struct address_space *mapping = file->f_mapping;
	struct inode *inode = mapping->host;
	unsigned long size;
	struct mm_struct *mm = vma->vm_mm;
	struct page *page;
	int err;

	/**
	 * 检查MAP_NONBLOCK标志，如果清0，就调用force_page_cache_readahead预读待映射文件的页。
	 */
	if (!nonblock)
		force_page_cache_readahead(mapping, vma->vm_file,
					pgoff, len >> PAGE_CACHE_SHIFT);

/**
 * 循环处理待映射的每一页。
 */
repeat:
	size = (i_size_read(inode) + PAGE_CACHE_SIZE - 1) >> PAGE_CACHE_SHIFT;
	if (pgoff + (len >> PAGE_CACHE_SHIFT) > size)
		return -EINVAL;

	/**
	 * 在高速缓存中查找页。
	 */
	page = filemap_getpage(file, pgoff, nonblock);
	/**
	 * 缓存中不存在，如果有MAP_NONBLOCK则退出。(等待NONBLOCK的流程将页面从磁盘读入)
	 */
	if (!page && !nonblock)
		return -ENOMEM;
	if (page) {/* 如果缓存中存在页，则将页设置到pte */
		err = install_page(mm, vma, addr, page, prot);
		if (err) {
			page_cache_release(page);
			return err;
		}
	} else {/* 页不在缓存中 */
		/**
		 * 如果没有在页高速缓存内找到该页描述符，它将文件页的偏移量存放在该线性地址对应的页表项的高32位，并将页表项的Present位清0，Dirty位置位
		 *
		 * 在页表中建立一个pte,其present位清0，dirty位置位。后续由缺页异常处理调页。
		 * handle_pte_fault调用do_file_page函数得到页索引，并调用线性区的populate方法读入页。
		 */
		err = install_file_pte(mm, vma, addr, pgoff, prot);
		if (err)
			return err;
	}

	len -= PAGE_SIZE;
	addr += PAGE_SIZE;
	pgoff++;
	if (len)
		goto repeat;

	return 0;
}

struct vm_operations_struct generic_file_vm_ops = {
	.nopage		= filemap_nopage,
	.populate	= filemap_populate,
};

/* This is used for a general mmap of a disk file */
/**
 * 大多数文件系统内存映射的mmap实现方法。
 */
int generic_file_mmap(struct file * file, struct vm_area_struct * vma)
{
	struct address_space *mapping = file->f_mapping;

	if (!mapping->a_ops->readpage)
		return -ENOEXEC;
	/**
	 * 将当前时间赋给i_atime字段，并将索引节点标记为脏
	 */
	file_accessed(file);
	/**
	 * 定义线程区的映射方法。
	 */
	vma->vm_ops = &generic_file_vm_ops;
	return 0;
}
EXPORT_SYMBOL(filemap_populate);

/*
 * This is for filesystems which do not implement ->writepage.
 */
int generic_file_readonly_mmap(struct file *file, struct vm_area_struct *vma)
{
	if ((vma->vm_flags & VM_SHARED) && (vma->vm_flags & VM_MAYWRITE))
		return -EINVAL;
	return generic_file_mmap(file, vma);
}
#else
int generic_file_mmap(struct file * file, struct vm_area_struct * vma)
{
	return -ENOSYS;
}
int generic_file_readonly_mmap(struct file * file, struct vm_area_struct * vma)
{
	return -ENOSYS;
}
#endif /* CONFIG_MMU */

EXPORT_SYMBOL(generic_file_mmap);
EXPORT_SYMBOL(generic_file_readonly_mmap);

static inline struct page *__read_cache_page(struct address_space *mapping,
				unsigned long index,
				int (*filler)(void *,struct page*),
				void *data)
{
	struct page *page, *cached_page = NULL;
	int err;
repeat:
	/**
	 * find_get_page检查页是否已经在页高速缓存中。
	 */
	page = find_get_page(mapping, index); /*★*/
	if (!page) {/* 页不在高速缓存中 */
		if (!cached_page) {
			/**
			 * 分配一个新页框。
			 */
			cached_page = page_cache_alloc_cold(mapping); /*★*/
			if (!cached_page)
				return ERR_PTR(-ENOMEM);
		}
		/**
		 * 在页高速缓存中插入相应的页描述符。
		 * 并把页插入管理区的非活动LRU链表中。
		 */
		err = add_to_page_cache_lru(cached_page, mapping,
					index, GFP_KERNEL); /*★*/
		if (err == -EEXIST)
			goto repeat;
		if (err < 0) {
			/* Presumably ENOMEM for radix tree node */
			page_cache_release(cached_page);
			return ERR_PTR(err);
		}
		page = cached_page;
		cached_page = NULL;
		err = filler(data, page); /*★*/ /*从磁盘读取页面内容*/
		if (err < 0) {
			page_cache_release(page);
			page = ERR_PTR(err);
		}
	}
	if (cached_page)
		page_cache_release(cached_page);
	return page;
}

/*
 * Read into the page cache. If a page already exists,
 * and PageUptodate() is not set, try to fill the page.
 */
/**
 * 确保高速缓存中包括最新版本的指定页。
 * mapping:   页所属的address_space
 * index:	  所请求页的偏移量的值
 * filter:    从磁盘读取页数据的回调函数
 * data:      传递给filter函数的指针，通常为NULL
 */
struct page *read_cache_page(struct address_space *mapping,
				unsigned long index,
				int (*filler)(void *,struct page*),
				void *data)
{
	struct page *page;
	int err;

retry:
	/*
	 * 确保页放入页缓存中，没有在页缓存中的建立新的页面
	 */
	page = __read_cache_page(mapping, index, filler, data); /*★*/
	if (IS_ERR(page))
		goto out;
	/**
	 * 页已经在页高速缓存中了，mark_page_accessed记录页已经被访问过的事实。
	 */
	mark_page_accessed(page);
	/**
	 * 查看页是否为最新。PG_uptodate为0表示页不是最新的。
	 */
	if (PageUptodate(page)) /*★*/
		goto out;

	/**
	 * 页不是最新的，调用filter从磁盘读取页，并设置PG_uptodate标志。(filter方法中设置update)
	 */
	lock_page(page);
	if (!page->mapping) {
		unlock_page(page);
		page_cache_release(page);
		goto retry;
	}
	if (PageUptodate(page)) {
		unlock_page(page);
		goto out;
	}
	err = filler(data, page); /*★*/
	if (err < 0) {
		page_cache_release(page);
		page = ERR_PTR(err);
	}
 out:
 	/*
 	 * 返回页面描述符地址
 	 */
	return page;
}

EXPORT_SYMBOL(read_cache_page);

/*
 * If the page was newly created, increment its refcount and add it to the
 * caller's lru-buffering pagevec.  This function is specifically for
 * generic_file_write().
 */
static inline struct page *
__grab_cache_page(struct address_space *mapping, unsigned long index,
			struct page **cached_page, struct pagevec *lru_pvec)
{
	int err;
	struct page *page;
repeat:
	page = find_lock_page(mapping, index);
	if (!page) {
		if (!*cached_page) {
			*cached_page = page_cache_alloc(mapping);
			if (!*cached_page)
				return NULL;
		}
		err = add_to_page_cache(*cached_page, mapping,
					index, GFP_KERNEL);
		if (err == -EEXIST)
			goto repeat;
		if (err == 0) {
			page = *cached_page;
			page_cache_get(page);
			if (!pagevec_add(lru_pvec, page))
				__pagevec_lru_add(lru_pvec);
			*cached_page = NULL;
		}
	}
	return page;
}

/*
 * The logic we want is
 *
 *	if suid or (sgid and xgrp)
 *		remove privs
 */
int remove_suid(struct dentry *dentry)
{
	mode_t mode = dentry->d_inode->i_mode;
	int kill = 0;
	int result = 0;

	/* suid always must be killed */
	if (unlikely(mode & S_ISUID))
		kill = ATTR_KILL_SUID;

	/*
	 * sgid without any exec bits is just a mandatory locking mark; leave
	 * it alone.  If some exec bits are set, it's a real sgid; kill it.
	 */
	if (unlikely((mode & S_ISGID) && (mode & S_IXGRP)))
		kill |= ATTR_KILL_SGID;

	if (unlikely(kill && !capable(CAP_FSETID))) {
		struct iattr newattrs;

		newattrs.ia_valid = ATTR_FORCE | kill;
		result = notify_change(dentry, &newattrs);
	}
	return result;
}
EXPORT_SYMBOL(remove_suid);

/*
 * Copy as much as we can into the page and return the number of bytes which
 * were sucessfully copied.  If a fault is encountered then clear the page
 * out to (offset+bytes) and return the number of bytes which were copied.
 */
static inline size_t
filemap_copy_from_user(struct page *page, unsigned long offset,
			const char __user *buf, unsigned bytes)
{
	char *kaddr;
	int left;

	kaddr = kmap_atomic(page, KM_USER0);
	left = __copy_from_user_inatomic(kaddr + offset, buf, bytes);
	kunmap_atomic(kaddr, KM_USER0);

	if (left != 0) {
		/* Do it the slow way */
		kaddr = kmap(page);
		left = __copy_from_user(kaddr + offset, buf, bytes);
		kunmap(page);
	}
	return bytes - left;
}

static size_t
__filemap_copy_from_user_iovec(char *vaddr, 
			const struct iovec *iov, size_t base, size_t bytes)
{
	size_t copied = 0, left = 0;

	while (bytes) {
		char __user *buf = iov->iov_base + base;
		int copy = min(bytes, iov->iov_len - base);

		base = 0;
		left = __copy_from_user_inatomic(vaddr, buf, copy);
		copied += copy;
		bytes -= copy;
		vaddr += copy;
		iov++;

		if (unlikely(left)) {
			/* zero the rest of the target like __copy_from_user */
			if (bytes)
				memset(vaddr, 0, bytes);
			break;
		}
	}
	return copied - left;
}

/*
 * This has the same sideeffects and return value as filemap_copy_from_user().
 * The difference is that on a fault we need to memset the remainder of the
 * page (out to offset+bytes), to emulate filemap_copy_from_user()'s
 * single-segment behaviour.
 */
static inline size_t
filemap_copy_from_user_iovec(struct page *page, unsigned long offset,
			const struct iovec *iov, size_t base, size_t bytes)
{
	char *kaddr;
	size_t copied;

	kaddr = kmap_atomic(page, KM_USER0);
	copied = __filemap_copy_from_user_iovec(kaddr + offset, iov,
						base, bytes);
	kunmap_atomic(kaddr, KM_USER0);
	if (copied != bytes) {
		kaddr = kmap(page);
		copied = __filemap_copy_from_user_iovec(kaddr + offset, iov,
							base, bytes);
		kunmap(page);
	}
	return copied;
}

static inline void
filemap_set_next_iovec(const struct iovec **iovp, size_t *basep, size_t bytes)
{
	const struct iovec *iov = *iovp;
	size_t base = *basep;

	while (bytes) {
		int copy = min(bytes, iov->iov_len - base);

		bytes -= copy;
		base += copy;
		if (iov->iov_len == base) {
			iov++;
			base = 0;
		}
	}
	*iovp = iov;
	*basep = base;
}

/*
 * Performs necessary checks before doing a write
 *
 * Can adjust writing position aor amount of bytes to write.
 * Returns appropriate error code that caller should return or
 * zero in case that write should be allowed.
 */
inline int generic_write_checks(struct file *file, loff_t *pos, size_t *count, int isblk)
{
	struct inode *inode = file->f_mapping->host;
	unsigned long limit = current->signal->rlim[RLIMIT_FSIZE].rlim_cur;

        if (unlikely(*pos < 0))
                return -EINVAL;

        if (unlikely(file->f_error)) {
                int err = file->f_error;
                file->f_error = 0;
                return err;
        }

	if (!isblk) {
		/* FIXME: this is for backwards compatibility with 2.4 */
		/**
		 * 如果不是块设备(即普通文件)
		 * 并且指定了O_APPEND，就将ppos设为文件尾。从而将新数据追加到文件的后面。
		 */
		if (file->f_flags & O_APPEND)
                        *pos = i_size_read(inode);

		/**
		 * 对文件大小进行检查。
		 * 此处是检查其限制值不能超过ulimit的限制。
		 */
		if (limit != RLIM_INFINITY) {
			if (*pos >= limit) {
				send_sig(SIGXFSZ, current, 0);
				return -EFBIG;
			}
			if (*count > limit - (typeof(limit))*pos) {
				*count = limit - (typeof(limit))*pos;
			}
		}
	}

	/*
	 * LFS rule
	 */
	/**
	 * 如果文件没有O_LARGEFILE标志，那么就不能超过2G。
	 */
	if (unlikely(*pos + *count > MAX_NON_LFS &&
				!(file->f_flags & O_LARGEFILE))) {
		if (*pos >= MAX_NON_LFS) {
			send_sig(SIGXFSZ, current, 0);
			return -EFBIG;
		}
		if (*count > MAX_NON_LFS - (unsigned long)*pos) {
			*count = MAX_NON_LFS - (unsigned long)*pos;
		}
	}

	/*
	 * Are we about to exceed the fs block limit ?
	 *
	 * If we have written data it becomes a short write.  If we have
	 * exceeded without writing data we send a signal and return EFBIG.
	 * Linus frestrict idea will clean these up nicely..
	 */
	/**
	 * 不能把一个普通文件增大到超过文件系统的上限。
	 */
	if (likely(!isblk)) {
		if (unlikely(*pos >= inode->i_sb->s_maxbytes)) {
			if (*count || *pos > inode->i_sb->s_maxbytes) {
				send_sig(SIGXFSZ, current, 0);
				return -EFBIG;
			}
			/* zero-length writes at ->s_maxbytes are OK */
		}

		if (unlikely(*pos + *count > inode->i_sb->s_maxbytes))
			*count = inode->i_sb->s_maxbytes - *pos;
	} else {
		loff_t isize;
		if (bdev_read_only(I_BDEV(inode)))
			return -EPERM;
		isize = i_size_read(inode);
		if (*pos >= isize) {
			if (*count || *pos > isize)
				return -ENOSPC;
		}

		if (*pos + *count > isize)
			*count = isize - *pos;
	}
	return 0;
}
EXPORT_SYMBOL(generic_write_checks);

ssize_t
generic_file_direct_write(struct kiocb *iocb, const struct iovec *iov,
		unsigned long *nr_segs, loff_t pos, loff_t *ppos,
		size_t count, size_t ocount)
{
	struct file	*file = iocb->ki_filp;
	struct address_space *mapping = file->f_mapping;
	struct inode	*inode = mapping->host;
	ssize_t		written;

	if (count != ocount)
		*nr_segs = iov_shorten((struct iovec *)iov, *nr_segs, count);

	written = generic_file_direct_IO(WRITE, iocb, iov, pos, *nr_segs); /*★*/
	if (written > 0) {
		loff_t end = pos + written;
		if (end > i_size_read(inode) && !S_ISBLK(inode->i_mode)) {
			i_size_write(inode,  end);
			mark_inode_dirty(inode);
		}
		*ppos = end;
	}

	/*
	 * Sync the fs metadata but not the minor inode changes and
	 * of course not the data as we did direct DMA for the IO.
	 * i_sem is held, which protects generic_osync_inode() from
	 * livelocking.
	 */
	if (written >= 0 && file->f_flags & O_SYNC)
		generic_osync_inode(inode, mapping, OSYNC_METADATA);
	if (written == count && !is_sync_kiocb(iocb))
		written = -EIOCBQUEUED;
	return written;
}
EXPORT_SYMBOL(generic_file_direct_write);

ssize_t
generic_file_buffered_write(struct kiocb *iocb, const struct iovec *iov,
		unsigned long nr_segs, loff_t pos, loff_t *ppos,
		size_t count, ssize_t written)
{
	struct file *file = iocb->ki_filp;
	struct address_space * mapping = file->f_mapping;
	struct address_space_operations *a_ops = mapping->a_ops;
	struct inode 	*inode = mapping->host;
	long		status = 0;
	struct page	*page;
	struct page	*cached_page = NULL;
	size_t		bytes;
	struct pagevec	lru_pvec;
	const struct iovec *cur_iov = iov; /* current iovec */
	size_t		iov_base = 0;	   /* offset in the current iovec */
	char __user	*buf;

	pagevec_init(&lru_pvec, 0);

	/*
	 * handle partial DIO write.  Adjust cur_iov if needed.
	 */
	if (likely(nr_segs == 1))
		buf = iov->iov_base + written;
	else {
		filemap_set_next_iovec(&cur_iov, &iov_base, written);
		buf = iov->iov_base + iov_base;
	}

	/**
	 * 循环处理每一页。
	 */
	do {
		unsigned long index;
		unsigned long offset;
		size_t copied;

		offset = (pos & (PAGE_CACHE_SIZE -1)); /* Within page */
		index = pos >> PAGE_CACHE_SHIFT;
		bytes = PAGE_CACHE_SIZE - offset;
		if (bytes > count)
			bytes = count;

		/*
		 * Bring in the user page that we will copy from _first_.
		 * Otherwise there's a nasty deadlock on copying from the
		 * same page as we're writing to, without it being marked
		 * up-to-date.
		 */
		fault_in_pages_readable(buf, bytes);

		/**
		 * __grab_cache_page会调用find_lock_page在页高速缓存中搜索该页。并增加引用计数后将它锁定。
		 * 如果该页不在页高速缓存中，则分配一个新页并调用add_to_page_cache在页高速缓存中插入此页。同时在内存管理区的非活动链表中插入一页。
		 */
		page = __grab_cache_page(mapping,index,&cached_page,&lru_pvec); /*★*/
		if (!page) {
			status = -ENOMEM;
			break;
		}

		/**
		 * 调用索引节点的prepare_write。对应的函数会为该页分配和初始化缓冲区首部。
		 * 普通文件     ext2_prepare_write
		 * 块设备文件   blkdev_prepare_write
		 */
		status = a_ops->prepare_write(file, page, offset, offset+bytes); /*★*/
		if (unlikely(status)) {
			loff_t isize = i_size_read(inode);
			/*
			 * prepare_write() may have instantiated a few blocks
			 * outside i_size.  Trim these off again.
			 */
			unlock_page(page);
			page_cache_release(page);
			if (pos + bytes > isize)
				vmtruncate(inode, isize);
			break;
		}
		/**
		 * 通过kmap建立临时映射，然后调用copy_from_user把用户态缓冲区中的字符拷贝到页中。然后释放临时映射。
		 */
		if (likely(nr_segs == 1))
			copied = filemap_copy_from_user(page, offset,
							buf, bytes); /*★*/
		else
			copied = filemap_copy_from_user_iovec(page, offset,
						cur_iov, iov_base, bytes);
		flush_dcache_page(page);
		/**
		 * commit_write方法将缓冲区标记为脏，以便随后将它们写回磁盘。
		 * 普通文件     generic_commit_write
		 * 块设备文件   blkdev_commit_write
		 */
		status = a_ops->commit_write(file, page, offset, offset+bytes);
		if (likely(copied > 0)) {
			if (!status)
				status = copied;

			if (status >= 0) {
				written += status;
				count -= status;
				pos += status;
				buf += status;
				if (unlikely(nr_segs > 1))
					filemap_set_next_iovec(&cur_iov,
							&iov_base, status);
			}
		}
		if (unlikely(copied != bytes))
			if (status >= 0)
				status = -EFAULT;
		/**
		 * 清除页面的PG_locked标志，并唤醒等待该页的任何进程。
		 */
		unlock_page(page);
		/**
		 * 设置页面访问标志。这为内存回收算法所使用。
		 */
		mark_page_accessed(page);
		/**
		 * 减少页引用计数。
		 */
		page_cache_release(page);
		if (status < 0)
			break;
		/**
		 * 检查页调整缓存中脏页比例是否超过一个固定的阀值(一般为系统中页的40%)，如果这样，则调用writeback_inodes来刷新几十页到磁盘。
		 */
		balance_dirty_pages_ratelimited(mapping);

		/**
		 * 增加一个抢占点。
		 */
		cond_resched();
	} while (count);

    /*
     * 现在，在写操作中所涉及的文件的所有页都已处理。更新*ppos的值，让它正好指向最优一个被写入的字符之后的位置
     */
	*ppos = pos;

	if (cached_page)
		page_cache_release(cached_page);

	/*
	 * For now, when the user asks for O_SYNC, we'll actually give O_DSYNC
	 */
	if (likely(status >= 0)) {
		if (unlikely((file->f_flags & O_SYNC) || IS_SYNC(inode))) {
			if (!a_ops->writepage || !is_sync_kiocb(iocb))
				status = generic_osync_inode(inode, mapping,
						OSYNC_METADATA|OSYNC_DATA);
		}
  	}
	
	/*
	 * If we get here for O_DIRECT writes then we must have fallen through
	 * to buffered writes (block instantiation inside i_size).  So we sync
	 * the file data here, to try to honour O_DIRECT expectations.
	 */
	if (unlikely(file->f_flags & O_DIRECT) && written)
		status = filemap_write_and_wait(mapping);

	pagevec_lru_add(&lru_pvec);
	return written ? written : status;
}
EXPORT_SYMBOL(generic_file_buffered_write);

ssize_t
__generic_file_aio_write_nolock(struct kiocb *iocb, const struct iovec *iov,
				unsigned long nr_segs, loff_t *ppos)
{
	struct file *file = iocb->ki_filp;
	struct address_space * mapping = file->f_mapping;
	size_t ocount;		/* original count */
	size_t count;		/* after file limit checks */
	/**
	 * 确定待写文件索引节点对象的inode。
	 * 如果文件是一个块设备文件，这就是一个bdev特殊文件系统的索引节点。
	 */
	struct inode 	*inode = mapping->host;
	unsigned long	seg;
	loff_t		pos;
	ssize_t		written;
	ssize_t		err;

	ocount = 0;
	for (seg = 0; seg < nr_segs; seg++) {
		const struct iovec *iv = &iov[seg];

		/*
		 * If any segment has a negative length, or the cumulative
		 * length ever wraps negative then return -EINVAL.
		 */
		ocount += iv->iov_len;
		if (unlikely((ssize_t)(ocount|iv->iov_len) < 0))
			return -EINVAL;
		/**
		 * 调用access_ok确定iovec描述符所描述的用户态缓冲区是有效的。
		 */
		if (access_ok(VERIFY_READ, iv->iov_base, iv->iov_len)) /*★*/
			continue;
		if (seg == 0)
			return -EFAULT;
		nr_segs = seg;
		ocount -= iv->iov_len;	/* This segment is no good */
		break;
	}

	count = ocount;
	pos = *ppos;

	vfs_check_frozen(inode->i_sb, SB_FREEZE_WRITE);

	/* We can write back this queue in page reclaim */
	/**
	 * 将文件的backing_dev_info设置为current->backing_dev_info
	 * 这样，即使相应请求队列是拥塞的，这个设置也会允许当前进程写回由file->f_mapping拥有的脏页。
	 */
	current->backing_dev_info = mapping->backing_dev_info;
	written = 0;

	/**
	 * 一些常规检查。
	 */
	err = generic_write_checks(file, &pos, &count, S_ISBLK(inode->i_mode)); /*★*/
	if (err)
		goto out;

	if (count == 0)
		goto out;

	/**
	 * 这里是设定文件权限。
	 */
	err = remove_suid(file->f_dentry); /*★*/
	if (err)
		goto out;

	/**
	 * 将当前时间存放在inode->mtime字段中，也存放在inode->ctime中。
	 * 二者分别表示文件写操作的最新时间，以及修改索引结点的最新时间中。
	 * 并且将索引节点对象标记为脏
	 */
	inode_update_time(inode, 1); /*★*/

	/* coalesce the iovecs and go direct-to-BIO for O_DIRECT */
	if (unlikely(file->f_flags & O_DIRECT)) {
		written = generic_file_direct_write(iocb, iov,
				&nr_segs, pos, ppos, count, ocount); /*★*/
		if (written < 0 || written == count)
			goto out;
		/*
		 * direct-io write to a hole: fall through to buffered I/O
		 * for completing the rest of the request.
		 */
		pos += written;
		count -= written;
	}

	/**
	 * 循环处理，以更新写操作中的所有文件页。
	 */
	written = generic_file_buffered_write(iocb, iov, nr_segs,
			pos, ppos, count, written);/*★*/
out:
	/**
	 * 恢复current->backing_dev_info
	 */
	current->backing_dev_info = NULL;
	return written ? written : err;
}
EXPORT_SYMBOL(generic_file_aio_write_nolock);

ssize_t
generic_file_aio_write_nolock(struct kiocb *iocb, const struct iovec *iov,
				unsigned long nr_segs, loff_t *ppos)
{
	struct file *file = iocb->ki_filp;
	struct address_space *mapping = file->f_mapping;
	struct inode *inode = mapping->host;
	ssize_t ret;
	loff_t pos = *ppos;

	ret = __generic_file_aio_write_nolock(iocb, iov, nr_segs, ppos); /*★*/

	if (ret > 0 && ((file->f_flags & O_SYNC) || IS_SYNC(inode))) {
		int err;

		err = sync_page_range_nolock(inode, mapping, pos, ret);
		if (err < 0)
			ret = err;
	}
	return ret;
}

ssize_t
__generic_file_write_nolock(struct file *file, const struct iovec *iov,
				unsigned long nr_segs, loff_t *ppos)
{
	struct kiocb kiocb;
	ssize_t ret;

	/**
	 * 初始化kiocb类型的局部变量。
	 */
	init_sync_kiocb(&kiocb, file);
	/**
	 * 该函数将的页标记为脏。
	 */
	ret = __generic_file_aio_write_nolock(&kiocb, iov, nr_segs, ppos);
	if (ret == -EIOCBQUEUED)
		ret = wait_on_sync_kiocb(&kiocb);
	return ret;
}

ssize_t
generic_file_write_nolock(struct file *file, const struct iovec *iov,
				unsigned long nr_segs, loff_t *ppos)
{
	struct kiocb kiocb;
	ssize_t ret;

	init_sync_kiocb(&kiocb, file);
	ret = generic_file_aio_write_nolock(&kiocb, iov, nr_segs, ppos);
	if (-EIOCBQUEUED == ret)
		ret = wait_on_sync_kiocb(&kiocb);
	return ret;
}
EXPORT_SYMBOL(generic_file_write_nolock);

ssize_t generic_file_aio_write(struct kiocb *iocb, const char __user *buf,
			       size_t count, loff_t pos)
{
	struct file *file = iocb->ki_filp;
	struct address_space *mapping = file->f_mapping;
	struct inode *inode = mapping->host;
	ssize_t ret;
	struct iovec local_iov = { .iov_base = (void __user *)buf,
					.iov_len = count };

	BUG_ON(iocb->ki_pos != pos);

	/* 获取节点的信号量 */
	down(&inode->i_sem);
	/* 进行实际的保存操作 */
	ret = __generic_file_aio_write_nolock(iocb, &local_iov, 1,
						&iocb->ki_pos);
	up(&inode->i_sem);/* 释放信号量 */

	/* 如果需要将数据同步到磁盘  */
	if (ret > 0 && ((file->f_flags & O_SYNC) || IS_SYNC(inode))) {
		ssize_t err;

		/* 将数据刷新到磁盘 */
		err = sync_page_range(inode, mapping, pos, ret);
		if (err < 0)
			ret = err;
	}
	return ret;
}
EXPORT_SYMBOL(generic_file_aio_write);

/**
 * 许多文件系统(如Ext2和JFS)通过本函数来实现文件对象的write方法。
 * file:		文件对象指针
 * buf:			用户态地址空间中的地址。
 * count:		要写入的字符个数。
 * ppos:		存放文件偏移量的变量地址，必须从这个偏移量处开始写入。
 */
ssize_t generic_file_write(struct file *file, const char __user *buf,
			   size_t count, loff_t *ppos)
{
	/**
	 * 确定所写文件索引节点对象的地址inode。
	 */
	struct address_space *mapping = file->f_mapping;
	struct inode *inode = mapping->host;
	ssize_t	ret;
	/**
	 * 初始化iovec类型的局部变量，以包含用户态缓冲区的地址和长度。
	 */
	struct iovec local_iov = { .iov_base = (void __user *)buf,
					.iov_len = count };

	/**
	 * 获得文件索引节点对象的信号量，这样一次只能有一个进程对某个文件发出write调用。
	 */
	down(&inode->i_sem);
	ret = __generic_file_write_nolock(file, &local_iov, 1, ppos); /*★*/
	/**
	 * 释放文件信号量。
	 */
	up(&inode->i_sem);

	/**
	 * 如果文件有O_SYNC标志，或者索引节点有S_SYNC标志，或者有MS_SYNCHRONOUS标志
	 */
	if (ret > 0 && ((file->f_flags & O_SYNC) || IS_SYNC(inode))) {
		ssize_t err;

		/**
		 * 强制内核将页高速缓存中的所有页刷新。阻塞当前进程直到IO数据传输结束。
		 */
		err = sync_page_range(inode, mapping, *ppos - ret, ret); /*★*/
		if (err < 0)
			ret = err;
	}
	return ret;
}
EXPORT_SYMBOL(generic_file_write);

ssize_t generic_file_readv(struct file *filp, const struct iovec *iov,
			unsigned long nr_segs, loff_t *ppos)
{
	struct kiocb kiocb;
	ssize_t ret;

	init_sync_kiocb(&kiocb, filp);
	ret = __generic_file_aio_read(&kiocb, iov, nr_segs, ppos);
	if (-EIOCBQUEUED == ret)
		ret = wait_on_sync_kiocb(&kiocb);
	return ret;
}
EXPORT_SYMBOL(generic_file_readv);

ssize_t generic_file_writev(struct file *file, const struct iovec *iov,
			unsigned long nr_segs, loff_t *ppos)
{
	struct address_space *mapping = file->f_mapping;
	struct inode *inode = mapping->host;
	ssize_t ret;

	down(&inode->i_sem);
	ret = __generic_file_write_nolock(file, iov, nr_segs, ppos);
	up(&inode->i_sem);

	if (ret > 0 && ((file->f_flags & O_SYNC) || IS_SYNC(inode))) {
		int err;

		err = sync_page_range(inode, mapping, *ppos - ret, ret);
		if (err < 0)
			ret = err;
	}
	return ret;
}
EXPORT_SYMBOL(generic_file_writev);

/*
 * Called under i_sem for writes to S_ISREG files.   Returns -EIO if something
 * went wrong during pagecache shootdown.
 */
/** 
 * 直接文件读写
 *		rw:		操作类型，READ或者WRITE。
 *		iocb:	kiocb描述符指针。
 *		iov:	iovec描述符数组指针。
 *		offset:	文件偏移量。
 *		nr_segs:iov数组中的iovec描述符数。
 */
ssize_t
generic_file_direct_IO(int rw, struct kiocb *iocb, const struct iovec *iov,
	loff_t offset, unsigned long nr_segs)
{
	/**
	 * 取得文件对象的地址，以及地址空间对象。
	 */
	struct file *file = iocb->ki_filp;
	struct address_space *mapping = file->f_mapping;
	ssize_t retval;

	/*
	 * If it's a write, unmap all mmappings of the file up-front.  This
	 * will cause any pte dirty bits to be propagated into the pageframes
	 * for the subsequent filemap_write_and_wait().
	 */
	/**
	 * 如果操作类型为WRITE，而且一个或者多个进程已经创建了与文件的某个部分关联的内存映射，则调用
	 * unmap_mapping_range取消该文件所有页的内存映射。如果任何取消映射的页所对应的页表项，其DIRTY位置为1，则该函数也确保它在页高速缓存中的相应页被被标记为脏。
	 */
	if (rw == WRITE && mapping_mapped(mapping))
		unmap_mapping_range(mapping, 0, -1, 0); /*★*/

	/**
	 * 如果nrpages不为空，则调用filemap_fdatawrite和filemap_fdatawait函数刷新所有脏页到磁盘。
	 * 并等待IO操作结束。
	 * 即使自缓存应用程度是直接访问文件的，系统中还可能通过页高速缓存访问文件的其他应用程序。
	 * 为了避免数据的丢失，在启动直接IO传送之前，磁盘映像要与页高速缓存进行同步。
	 */
	retval = filemap_write_and_wait(mapping); /*★*/
	if (retval == 0) {
		/**
		 * 调用mapping地址空间的direct_io方法。
		 * 大多数情况调用  __blockdev_direct_IO()
		 */
		retval = mapping->a_ops->direct_IO(rw, iocb, iov,
						offset, nr_segs); /*★*/
		/**
		 * 如果操作类型是write，则调用invalidate_inode_pages2扫描mapping基树中所有页并释放它们。
		 * 同时也清空指向这些页的用户态页表项。
		 */
		if (rw == WRITE && mapping->nrpages) {
			int err = invalidate_inode_pages2(mapping);
			if (err)
				retval = err;
		}
	}
	return retval;
}
EXPORT_SYMBOL_GPL(generic_file_direct_IO);

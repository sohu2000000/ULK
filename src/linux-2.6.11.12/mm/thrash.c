/*
 * mm/thrash.c
 *
 * Copyright (C) 2004, Red Hat, Inc.
 * Copyright (C) 2004, Rik van Riel <riel@redhat.com>
 * Released under the GPL, see the file COPYING for details.
 *
 * Simple token based thrashing protection, using the algorithm
 * described in:  http://www.cs.wm.edu/~sjiang/token.pdf
 */
#include <linux/jiffies.h>
#include <linux/mm.h>
#include <linux/sched.h>
#include <linux/swap.h>

static DEFINE_SPINLOCK(swap_token_lock);
static unsigned long swap_token_timeout;
unsigned long swap_token_check;
/*
 * 交换标记的具体体现形式是swap_token_mm内存描述符指针。当进程拥有交换标记时，swap_token_mm被设置为进程内存描述符的地址
 */
struct mm_struct * swap_token_mm = &init_mm;

#define SWAP_TOKEN_CHECK_INTERVAL (HZ * 2)
#define SWAP_TOKEN_TIMEOUT	0
/*
 * Currently disabled; Needs further code to work at HZ * 300.
 */
unsigned long swap_token_default_timeout = SWAP_TOKEN_TIMEOUT;

/*
 * Take the token away if the process had no page faults
 * in the last interval, or if it has held the token for
 * too long.
 */
#define SWAP_TOKEN_ENOUGH_RSS 1
#define SWAP_TOKEN_TIMED_OUT 2
static int should_release_swap_token(struct mm_struct *mm)
{
	int ret = 0;
    /*
     * 当前拥有交换标记的进程没有再次提出缺页
     */
	if (!mm->recent_pagein)
		ret = SWAP_TOKEN_ENOUGH_RSS;
    /*
     * 当前拥有交换标记的进程的时间超出了swap_token_default_timeout
     */
	else if (time_after(jiffies, swap_token_timeout))
		ret = SWAP_TOKEN_TIMED_OUT;
    /*
     * 去掉当前拥有交换标记进程进程的再次发生缺页的标记
     */
	mm->recent_pagein = 0;
	return ret;
}

/*
 * Try to grab the swapout protection token.  We only try to
 * grab it once every TOKEN_CHECK_INTERVAL, both to prevent
 * SMP lock contention and to check that the process that held
 * the token before is no longer thrashing.
 */
/**
 * 决定是否将交换标记赋给当前进程。在主缺页时调用:
 *		当filemap_nopage函数发现请求页不在页高速缓存中时。
 *		当do_swap_page函数从交换区读入一个新页时。
 */
void grab_swap_token(void)
{
	struct mm_struct *mm;
	int reason;

	/* We have the token. Let others know we still need it. */
	/**
	 * 已经有交换标记了，仅仅设置主缺页标记就行了。
	 * recent_pagein = 1说明本进程在获得交换标记不久后又再次发生了缺页(因为本函数只会在缺页时候被调用)
	 */
	if (has_swap_token(current->mm)) {
		current->mm->recent_pagein = 1;
		return;
	}

	/**
	 * 自从上次设置交换标记以来，已经过了两秒。
	 */
	if (time_after(jiffies, swap_token_check)) {

		/* Can't get swapout protection if we exceed our RSS limit. */
		// if (current->mm->rss > current->mm->rlimit_rss)
		//	return;

		/* ... or if we recently held the token. */
		/**
		 * 上次调用后，当前拥有交换标记的进程最近没有再获得标记。
		 */
		if (time_before(jiffies, current->mm->swap_token_time))
			return;

		if (!spin_trylock(&swap_token_lock))
			return;

		swap_token_check = jiffies + SWAP_TOKEN_CHECK_INTERVAL;

        /*
         * 得到当前拥有交换标记进程的进程描述符
         */
		mm = swap_token_mm;

        /*
         * 满足下面条件才赋予交换标记
         *  当前拥有交换标记的进程没有再次提出缺页
         *  当前拥有交换标记的进程的时间超出了swap_token_default_timeout
         */        
		if ((reason = should_release_swap_token(mm))) {
			unsigned long eligible = jiffies;
			if (reason == SWAP_TOKEN_TIMED_OUT) {
				eligible += swap_token_default_timeout;
			}
			mm->swap_token_time = eligible;
			swap_token_timeout = jiffies + swap_token_default_timeout;
            /*
             * 将交换标记赋给当前进程
             */
			swap_token_mm = current->mm;
		}
		spin_unlock(&swap_token_lock);
	}
	return;
}

/* Called on process exit. */
void __put_swap_token(struct mm_struct *mm)
{
	spin_lock(&swap_token_lock);
	if (likely(mm == swap_token_mm)) {
		swap_token_mm = &init_mm;
		swap_token_check = jiffies;
	}
	spin_unlock(&swap_token_lock);
}
